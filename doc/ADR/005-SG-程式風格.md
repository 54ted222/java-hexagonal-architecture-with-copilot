# 005-SG-程式風格

- 2025/11/16 (架構師) - 初始版本

## 基本資訊 (Basic Information)

- 規範性質 (Nature): 建議性 (Recommendation)
- 狀態 (Status):
- 決策日期 (Decision Date):
- 決策者 (Deciders):
- 相關決策 (Related Decisions):
  1. [001-ADR](./001-ADR-ADR文件規範.md): ADR 文件規範
  2. [003-Arch](./003-Arch-SOLID%20原則.md): SOLID 原則
- 背景 (Context):
  1. 統一程式碼風格有助於提升程式碼可讀性與可維護性
  2. 明確的程式碼撰寫慣例可減少程式碼審查的爭議
  3. 團隊使用 AI 工具輔助開發，明確的風格規範有助於 AI 生成一致性的程式碼

## 決策內容 (Decision)

### 提早返回 (Early Return) / 使用衛語句 (Guard Clauses) / 提早拋出例外 (Early Throw)

優先使用提早返回減少巢狀結構，提升可讀性。

```java
// ❌ 避免：巢狀結構
public User getUser(Long id) {
    if (id != null) {
        User user = userRepository.findById(id);
        if (user != null) {
            if (user.isActive()) {
                return user;
            }
        }
    }
    return null;
}

// ✅ 推薦：提早返回
public User getUser(Long id) {
    if (id == null) return null;

    User user = userRepository.findById(id);
    if (user == null) throw new IllegalArgumentException("使用者不可為空");
    if (!user.isActive()) return null;

    return user;
}
```

### 策略模式取代條件判斷

使用策略模式取代大量重複的 if-return 或 switch，提升擴展性。

```java
// ❌ 避免：冗長的條件判斷
public String encodePassword(String password, String type) {
    if ("BCrypt".equals(type)) return bCryptEncoder.encode(password);
		if ("SHA256".equals(type)) return sha256Encoder.encode(password);
		if ("MD5".equals(type)) return md5Encoder.encode(password);
		// if() * 100 more
    throw new IllegalArgumentException("不支援的加密類型");
}

// ✅ 推薦：策略模式
interface PasswordEncoder {
    String encode(String password);
}

@Service
class PasswordEncoderFactory {
    private final Map<String, PasswordEncoder> encoders;

    public PasswordEncoderFactory(List<PasswordEncoder> encoderList) {
        this.encoders = encoderList.stream()
            .collect(Collectors.toMap(
                e -> e.getClass().getSimpleName(),
                e -> e
            ));
    }

    public String encode(String password, String type) {
        PasswordEncoder encoder = encoders.get(type);
        if (encoder == null) throw new IllegalArgumentException("不支援的加密類型: " + type);
        return encoder.encode(password);
    }
}
```

### 優先使用 Stream API 與 For-Each

使用現代 Java 語法，避免傳統 for 迴圈的索引操作。

```java
// ❌ 避免：傳統 for 迴圈
public List<String> getActiveUsernames(List<User> users) {
    List<String> usernames = new ArrayList<>();
    for (int i = 0; i < users.size(); i++) {
        User user = users.get(i);
        if (user.isActive()) {
            usernames.add(user.getUsername());
        }
    }
    return usernames;
}

public List<String> getActiveUsernames(List<User> users) {
		List<String> result = new ArrayList<>();
		// ✅ 優先推薦：Stream API
    result =  users.stream()
        .filter(User::isActive)
        .map(User::getUsername)
        .collect(Collectors.toList());

		// ✅ 其次推薦：For-Each (簡單操作)
		for (User user : users) {
        if (!user.isActive()) continue; // ✅ 推薦：提早返回
        result.add(user.getUsername());
    }
}

```

### 使用 Optional 處理空值

使用 `Optional` 明確表示可能為空的返回值，避免 `NullPointerException`。

```java
// ❌ 避免：返回 null
public User findByUsername(String username) {
    return userRepository.findByUsername(username); // 可能返回 null
}

// ✅ 推薦：使用 Optional
public Optional<User> findByUsername(String username) {
    return Optional.ofNullable(userRepository.findByUsername(username));
}
```

### 使用 Callback 將模板程式委外處理

```java
// ❌ 避免：重複模板程式碼
public List<User> processCSVFile(String filePath) {

		try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
				String line;
				while ((line = br.readLine()) != null) {
						String[] values = line.split(",");
						User user = new User();
						user.setId(values[0]);
						user.setUsername(values[1]);
						user.setEmail(values[2]);
						user.setActive(Boolean.parseBoolean(values[2]));

						if (!user.getId()) throw new IllegalArgumentException("使用者 ID 不可為空");
						if (!isValid(user)) continue;

						repository.save(user);
				}
		} catch (IOException e) {
				e.printStackTrace();
				throw new BusinessException(ErrorCode.C0013,"處理 CSV 檔案失敗", e);
		}
		return users;
}

// ✅ 推薦：使用 Callback 將模板程式委外處理
public void processCSVFile() {
		// 不一定要是Singleton，可以是每次 new 出來使用
		UserFileProcessor processor = new UserFileProcessor("path/to/file.csv");
		processor.setErrorCode(ErrorCode.C0013);
		processor.process((User user) -> {
			if (!user.getId()) throw new IllegalArgumentException("使用者 ID 不可為空");
			if (!isValid(user)) return;
			repository.save(user);
		});
}
```

### 例外處理

- 優先使用 全域通用的 Error Handler 處理未捕捉的例外與紀錄 Log
- ErrorCode 要提供一個 通用錯誤，避免定義過多沒有意義的錯誤碼，程式細節可用額外資訊區分
- 避免直接使用通用例外 RuntimeException
- 避免直接 catch `Error` 或 `Throwable`，只有繼承 `Exception` 的例外才可以 catch
- finally 區塊應盡量避免有可能拋出例外的程式碼，且不可以有 return 語句

```java
// ❌ 避免：將 Exception 的 Message 作為可見訊息回傳給使用者
new BusinessException(ErrorCode.C0013, "哎呀！系統發生問題\n請聯絡客服 0800-0000", e);

// ✅ 推薦：將 Exception 的 Message 明確描述錯誤原因
new BusinessException(ErrorCode.C0013, "處理 CSV 檔案失敗", e)
	.setExtraInfo("filePath:", filePath); // 可選，提供額外除錯資訊 用於日誌記錄

```

```java
// ❌ 避免：不要在每個方法中捕捉並透過 return 方式處理例外邏輯，除非需要特定的業務處理邏輯
public int process(String filePath) {
		try {
			var user = repo.getById(id);
				if (user == null) {
					return 0; //0 代表處理失敗
				}
				// 處理邏輯
				return 1;
		} catch (IOException e) {
				log.debug(e.printStackTrace(),e); // 只記錄日誌
				return 1;
		}
}

// ✅ 推薦：使用 全域通用的 Error Handler 處理未捕捉的例外與紀錄 Log
public void process(String filePath) {
		// 處理邏輯
		var user = repo.getById(id);
		if (user == null) throw new BusinessException(ErrorCode.C0020, "找不到使用者 ID: " + id);

}
```
